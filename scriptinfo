#!/bin/bash

version=1.04
myname=scriptinfo

<<'DOC'
= scriptinfo - for script with gendoc documentation, print concise info

= Synopsis
scriptinfo [options] scriptname	

Options:
-h|--help	print short help and exit
-H|--Help	print full documentation and exit
-V|--version	print version and exit
-b|--brief	print brief output for usage in scripts
-n|--nocolor	print without ANSI coloring sequences
-m|--markdown	use markdown for bitbucket-compatible output
-o|--options	list the options and exits

= Description
For a script with /gendoc/ documentation, scriptinfo prints the script's 
short description, type, version, intro, and changes.

If the script has no path information and is not found, it is looked up in PATH.
- type is found in the shebang line.
- short description is found in the line starting with: |= <scriptname> - |
- version must be on a single line and may be capitalized;
  the first occurrence will be used.  Recognized formats are:
    version = 1.23
    $version = 1.23
    my $version = 1.23
    version => 1.23a
    version = "1.23"
    version = '1.23d'
  Whitespace in these formats may be arbirarily long or absent,
  including at the start of the line, anything may follow at the end,
  but a single lower letter will be part of the version number.
- intro is the first paragraph after the line starting with |= Description|
- changes is the first paragraph after the line starting with |= Changes|

The output of scriptinfo comes in three formats. The default is the long format,
which for scriptinfo itself is like this:
  
    script:  scriptinfo - find script's type, version, short description
    type:    bash
    version: 1.00
    
    For a script with /gendoc/ documentation, scriptinfo prints the script's
    short description, type, version, intro, and changes.
    
    Initial version

Without the |--nocolor| option the script's name and strings enclosed in
pipe symbols will be ANSI colored.

With the |--brief| option, exactly 5 lines are output, one for each of
short description, type, version, intro, and changes.
This is the output used by the /instscript/ and /gendoc/ scripts.

With the |--markdown| option, a markdown version is produced, which is
useful as a README file for bitbucket uploads. This option disables the 
|--brief| option and sets the |--nocolor| option.

The |--options| option is useful when writing the documentation for a shell script. 
When the option handler contains lines like this:

   (-o|--option)	# this option does nothing

then the command:
   scriptinfo -o script
will generate lines like this:

-o,--option	this option does nothing

which can be inserted in the documentation. When you are editing the script with vim,
you can insert such lines by giving the ex-command:
  :r!scriptinfo -o %

= C binaries
My C binaries are compiled from bash scripts that copy their /gendoc/ documentation into
the C-source as text for the -h option; by inserting a newline before the text it is
ensured that all lines can be grepped from the binary. The version information is not in
these lines: it is obtained by running the binary with the |-V| option, which must have
been programmed, of course.

= Author and copyright
Author	Wybo Dekker
Email	U{Wybo@dekkerdocumenten.nl}{wybo@dekkerdocumenten.nl}
License	Released under the U{www.gnu.org/copyleft/gpl.html}{GNU General Public License}
DOC

    die() { echo -e "$myname: $Err$@$Nor" 1>&2; exit 1; }
   help() { sed -n '/^= Synopsis/,/^= /p' $0|sed '1s/.*/Usage:/;/^= /d'; exit; }
helpall() { sed -n '/^<<.DOC.$/,/^DOC$/p' $0|sed -n '1d;$d;p'|less; exit; }
   Warn() { echo -e "$myname: $War${*}$Nor"; } 1>&2
   warn() { $verbose && Warn "$@"; }
version() { echo $version; exit; }
install() { which instscript>&/dev/null && instscript --pdf --markdown $myname; exit; }

Err='[31;1m' # light red	]
War='[35;1m' # light magenta	]
Fil='[33m'   # brown		]
Com='[34;1m' # light blue	]
Nor='[0m'    # reset color	]

if ! options=$(getopt \
   -n $myname \
   -o hHVIbnom \
   -l help,Help,version,brief,nocolor,markdown,options \
   -- "$@"
); then exit 1; fi
eval set -- "$options"
brief=false
color=true
markdown=false
listoptions=false
while [ $# -gt 0 ]; do
   case $1 in 
   (-h|--help)		# print short help and exit
	 help;;
   (-H|--Help)		# print full documentation and exit
	 helpall;;
   (-V|--version)	# print version and exit
	 version;;
   (-b|--brief)		# print brief output for usage in scripts
	 brief=true; shift;;
   (-n|--nocolor)	# print without ANSI coloring sequences
	 color=false; shift;;
   (-m|--markdown)	# use markdown for bitbucket-compatible output
	 markdown=true; shift;;
   (-o|--options)	# list the options and exits
	 listoptions=true; shift;;
   (-I)  install;;
   (--)  shift;  break;;
   (*)	 break;;
   esac
done

script="$1"
test -z "$script" && die "I need a script name"
if [[ ! -f $script ]]; then
   if [[ $script =~ / ]]; then
      [[ -e $script ]] || die $script: does not exist
      [[ -f $script ]] || die $script: not a regular file
   else
      script=$(which "$1")
      [[ -z $script ]] && die $1: not found here, nor in PATH
   fi
fi
if [[ -L $script ]]; then
   script=$(readlink -f $script)
fi

if $listoptions; then
   sed -n 's/|--/,--/;s/^   (\(.*\)).*# \(.*\)/\1\t\2/p' $script |unexpand
   exit
fi

scriptversion= type= short= n=0 scriptname=${script##*/} intro= changes=
author= email= license= see= indoc=false
while read -r line; do
   # type
   [[ $((n++)) = 0 && 
      $line =~ (bash|ruby|perl|python|sh|C) ]] &&
      type=${BASH_REMATCH[1]}
   if $indoc; then
      # end of DOC?
      [[ $line =~ ^DOC ]] && break
      # short description
      [[ -z $short &&
         $line =~ ^=\ $scriptname\ -\ (.*) ]] &&
         short=${BASH_REMATCH[1]}
      # intro: first paragraph after Description header
      [[ $line =~ ^=\ Description ]] && {
         while read -r line; do 
            test -n "$line" && intro+="$line\n" || break
         done
      }
      # changes: first paragraph after Changes header   
      [[ $line =~ ^=\ Changes ]] && {
         while read -r line; do 
            test -n "$line" && changes+="$line\n" || break
         done
      }    
      # author, email, license:
      [[ $line =~ ^=\ Author ]] && {
         read -r line; author=${line#Author	}
         read -r line; IFS=$'\}\{' read -r i i i email <<<$line
         read -r i line; license=$(sed 's/U{[^}]*}{\(.*\)}/\1/' <<<$line)
      }
   else
      # start of DOC?
      [[ $line =~ ^\<\<\'DOC\' ]] && indoc=true
      # version: use first match
      [[ -z $scriptversion &&
         $line =~ ^[[:space:]]*\$?[Vv]ersion[[:space:]]*=\>?[[:space:]]*[\"\']?([[:digit:]]+\.[[:digit:]]+[a-z]*) ]] &&
         scriptversion=${BASH_REMATCH[1]}
   fi
done < <(
   if [[ $(file --mime "$script") =~ binary$ ]]; then
      echo '#!/bin/C'
      v=$($script -V) || die "$script does not respond to -V option"
      echo version=$v
      echo "<<'DOC'"
      $script -h || die "$script does not respond to -h option"
      echo DOC
   else
      sed -e "s/#[^!].*//" "$script"
   fi
)

if [ -z $scriptversion ]; then
   Warn "No version info in $script; check if the version was correctly formatted\n" \
        "and placed before the gendoc documentation"
fi
if [ $markdown = true ]; then 
   color=false
   brief=false
   changes=$(sed 's/|//g' <<<$changes)
   intro=$(sed 's/|//g' <<<$intro)
   head="|\n-------:|:--------------------------------------"
   s=':|' # column separator
   l=     # paragraph separator
else
   s=':'
   head=
   l="--------------------------------------------------------------------------------"
fi

unk='<??>'
if $brief; then
   echo ${short:-$unk}
   echo ${type:-$unk}
   echo ${scriptversion:-$unk}
   echo -e ${intro:-$unk}
else 
   $color && sedscript="s/\<$scriptname\>/${Fil}&$Nor/g;s/|\([^][^|]*\)|/$Com\1$Nor/g"
      
 ( test -z $head || echo -e $head
   echo -e " script$s $scriptname - ${short:-$unk}"
   echo    "   type$s ${type:-$unk}"
   echo    " author$s ${author:-$unk}"
   echo    "  email$s ${email:-$unk}"
   echo    "version$s ${scriptversion:-$unk}"
   echo    "license$s ${license:-$unk}"
   echo $l
   echo -e "${intro:-$unk}"
   test -n "$changes" && echo -e "Recent changes:\n$changes" ) |
   sed -e "$sedscript"
fi
