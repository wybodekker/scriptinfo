#!/bin/bash

Version=1.08
Myname="${0##*/}"

:<<'DOC'
= scriptinfo - for script with gendoc documentation, print concise info

= Synopsis
scriptinfo [options] scriptname	

== Options
-h|--help	print short help and exit
-H|--Help	print full documentation and exit
-V|--version	print version and exit
-b|--brief	print brief output for usage in scripts
-n|--nocolor	print without ANSI coloring sequences
-m|--markdown	use markdown for bitbucket-compatible output
-o|--options	list the options and exits

= Description
For a script with /gendoc/ documentation, scriptinfo prints the script's 
short description, type, version, intro, and changes.

If the script has no path information and is not found, it is looked up in PATH.
- type is found in the shebang line.
- short description is found in the line starting with: |= <scriptname> - |
- version must be on a single line and may be capitalized;
  the first occurrence will be used.  Recognized formats are:
    version = 1.23
    $version = 1.23
    my $version = 1.23
    version => 1.23a
    version = "1.23"
    version = '1.23d'
  Whitespace in these formats may be arbirarily long or absent,
  including at the start of the line, anything may follow at the end,
  but a single lower letter will be part of the version number.
- intro is the first paragraph after the line starting with |= Description|
- changes is the first paragraph after the line starting with |= Changes|

The output of scriptinfo comes in three formats. The default is the long format,
which for scriptinfo itself is like this:
  
    script:  scriptinfo - find script's type, version, short description
    type:    bash
    version: 1.00
    
    For a script with /gendoc/ documentation, scriptinfo prints the script's
    short description, type, version, intro, and changes.
    
    Initial version

Without the |--nocolor| option the script's name and strings enclosed in
pipe symbols will be ANSI colored.

With the |--brief| option, exactly 3 lines are output, one for each of
short description, type, version.
This is the output used by the /instscript/ and /gendoc/ scripts.

With the |--markdown| option, a markdown version is produced, which is
useful as a README file for bitbucket uploads. This option disables the 
|--brief| option and sets the |--nocolor| option.

The |--options| option is useful when writing the documentation for a shell script. 
When the option handler contains lines like this:

   (-o|--option)	# this option does nothing

then the command:
   scriptinfo -o script
will generate lines like this:

-o,--option	this option does nothing

which can be inserted in the documentation. When you are editing the script with vim,
you can insert such lines by giving the ex-command:
  :r!scriptinfo -o %

= C binaries
My C binaries are compiled from bash scripts that copy their /gendoc/ documentation into
the C-source as text for the -h option; by inserting a newline before the text it is
ensured that all lines can be grepped from the binary. The version information is not in
these lines: it is obtained by running the binary with the |-V| option, which must have
been programmed, of course.

= Author
[Wybo Dekker](wybo@dekkerdocumenten.nl)

= Copyright
Released under the [GNU General Public License](www.gnu.org/copyleft/gpl.html)
DOC

REd='[38;5;9m'
Mag='[38;5;5m'
Nor='[0m'
YeL='[1;38;5;3m'
BlU='[1;38;5;4m'
    die() { local i
	    for i; do
		echo -e "$Myname: $REd$i"
	    done 1>&2
	    exit 1
	  }
   Warn() { local i; for i; do echo -e "$Myname: $Mag$i$Nor"; done 1>&2; }
helpsrt() { sed -n '/^= Synopsis/,/^= /p' "$0"|sed '1d;$d'; exit; }
instscr() { instscript --zip --pdf "$Myname"; exit; }

# shellcheck disable=SC2154
helpall() { sed -n "/^:\?<<'DOC'$/,/^DOC/p" "$0"|sed -n '1d;$d;p'|
            less -Ps"$Myname-${Version/./Â·} documentation - type h for help, q to quit."
		exit
	  }
nocolor() { REd='' Mag='' Nor='' YeL='' BlU=''; }

if ! options=$(getopt \
   -n "$Myname" \
   -o hHVIbnom \
   -l help,Help,version,brief,nocolor,markdown,options \
   -- "$@"
); then exit 1; fi
eval set -- "$options"
brief=false
markdown=false
listoptions=false
while [ $# -gt 0 ]; do
   case $1 in 
   (-h|--help)     # print short help and exit
                   helpsrt
                   ;;
   (-H|--Help)     # print full documentation and exit
                   helpall
                   ;;
   (-V|--version)  # print version and exit
                   echo $Version
		   exit
                   ;;
   (-b|--brief)    # print brief output for usage in scripts
                   brief=true
                   shift
                   ;;
   (-n|--nocolor)  # print without ANSI coloring sequences
                   nocolor
                   shift
                   ;;
   (-m|--markdown) # use markdown for bitbucket-compatible output
                   markdown=true
                   shift
                   ;;
   (-o|--options)  # list the options and exits
                   listoptions=true
                   shift
                   ;;
   (-I)            instscr
                   ;;
   (--)            shift
                   break
                   ;;
   (*)             break
                   ;;
   esac
done

script="$1"
test -z "$script" && die "I need a script name"
if [[ ! -f $script ]]; then
   if [[ $script =~ / ]]; then
      [[ -e $script ]] || die "$script: does not exist"
      [[ -f $script ]] || die "$script: not a regular file"
   else
      script=$(command -v "$1")
      [[ -z $script ]] && die "$1: not found here, nor in PATH"
   fi
fi
if [[ -L $script ]]; then
   script=$(readlink -f "$script")
fi

if $listoptions; then
   while IFS= read -r line; do
      # skip DOC:
      if [[ $line =~ ^:\<\<\'DOC\' ]]; then
         while read -r line; do 
            [[ $line = DOC ]] && break
         done
      fi
      # find getopt entries:
      if [[ $line =~ ^[[:space:]]+\((.*--[A-Za-z]+)\)[[:space:]]+#\ (.*) ]]; then 
         echo -e "${BASH_REMATCH[1]}\t${BASH_REMATCH[2]}"
         while IFS= read -r line; do
            [[ $line =~ ^[[:space:]]+#\ (.*) ]] || break
            echo -e "\t\t${BASH_REMATCH[1]}"
         done
      fi
   done <"$script"
   exit
fi

scriptversion='' type='' short='' n=0 scriptname=${script##*/} intro='' changes=
author='' email='' license='' indoc=false
while read -r line; do
   # type
   [[ $((n++)) = 0 && 
      $line =~ (bash|ruby|perl|python|sh|C) ]] &&
      type=${BASH_REMATCH[1]}
   if $indoc; then
      # end of DOC?
      [[ $line =~ ^DOC ]] && break
      # short description
      if [[ -z $short && $line =~ ^=\ $scriptname\ -\ (.*) ]]; then
         short=${BASH_REMATCH[1]}
      fi
      # intro: first paragraph after Description header
      [[ $line =~ ^=\ Description ]] && {
         while read -r line; do 
            if [ -n "$line" ]; then
               intro+="$line\n"
            else
               break
            fi
         done
      }
      # changes: first paragraph after Changes header   
      [[ $line =~ ^=\ Changes ]] && {
         while read -r line; do 
            if [ -n "$line" ]; then
               changes+="$line\n"
            else
               break
            fi
         done
      }    
      # author, email, license:
      if [[ $line =~ ^=\ Author ]]; then
         read -r line
         if [[ $line =~ \[(.*)\]\((.*)\) ]]; then
            author=${BASH_REMATCH[1]}
            email=${BASH_REMATCH[2]}
         fi
      fi
      # license:
      if [[ $line =~ ^=\ Copyright ]]; then
         read -r line
         if [[ $line =~ \[(.*)\] ]]; then
            license=${BASH_REMATCH[1]}
         fi
      fi
   else
      # start of DOC?
      [[ $line =~ ^:?\<\<\'DOC\' ]] && indoc=true
      # version: use first match
      shopt -s nocasematch
      if [[ -z $scriptversion && 
         $line =~ ^[[:space:]]*\$?version[[:space:]]*=\>?[[:space:]]*[\"\']?([[:digit:]]+\.[[:digit:]]+[a-z]*) ]]; then
         scriptversion=${BASH_REMATCH[1]}
      fi
      shopt -u nocasematch
   fi
done < <(
   if [[ $(file --mime "$script") =~ binary$ ]]; then
      echo '#!/bin/C'
      v=$($script -V) || die "$script does not respond to -V option"
      echo version="$v"
      echo ":<<'DOC'"
      $script -H || die "$script does not respond to -H option"
      echo DOC
   else
      sed -e "s/#[^!].*//" "$script"
   fi
)

if [[ -z $scriptversion ]]; then
   Warn "No version info in $script; check if the version was correctly formatted" \
        "and placed before the gendoc documentation"
fi
if [ $markdown = true ]; then 
   nocolor
   brief=false
   changes="${changes//|/}"
   intro="${intro//|/}"
   head="|\n-------:|:--------------------------------------"
   s=':|' # column separator
   l=''     # paragraph separator
else
   s="$Nor:"
   head=
   l="--------------------------------------------------------------------------------"
fi

unk='<??>'
if $brief; then
   echo "${short:-$unk}"
   echo "${type:-$unk}"
   echo "${scriptversion:-$unk}"
else
   sedscript="s/\<$scriptname\>/${YeL}&$Nor/g;s/|\([^][^|]*\)|/$BlU\1$Nor/g"
   test -z $head || echo -e $head
   echo -e "${BlU} script$s $YeL$scriptname$Nor - ${short:-$unk}"
   echo -e "${BlU}   type$s ${type:-$unk}"
   echo -e "${BlU} author$s ${author:-$unk}"
   echo -e "${BlU}  email$s ${email:-$unk}"
   echo -e "${BlU}version$s ${scriptversion:-$unk}"
   echo -e "${BlU}license$s ${license:-$unk}"
   echo $l
   echo -e "${intro:-$unk}" | sed -e "$sedscript"
   test -n "$changes" && echo -e "${BlU}Recent changes$Nor:\n$changes"
fi
